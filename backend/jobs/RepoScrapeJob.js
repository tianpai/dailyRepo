import { getRepo, getTrending } from "../services/RepoScraping.js";
import { getTodayUTC } from "../utils/time.js";
import { calculateTrendScore } from "../utils/trendScore.js";
import Repo from "../models/Repo.js";

/**
 * Turn the full GitHub repo payload + languages into your DB object.
 *
 * @param {Object} data           The raw repo JSON from getRepo()
 * @param {Object} languages      The object from fetchLanguages()
 * @param {string} today          A date string like "2025-05-04"
 * @returns {Object}              Cleaned-up repo document ready to save
 */
function transformRepo(data, languages, today) {
  // API Raw data
  const {
    name,
    full_name,
    description,
    html_url,
    license,
    created_at,
    updated_at,
    topics = [],
    stargazers_count: starsCount,
    forks_count: forksCount,
    subscribers_count: watchesCount,
    owner: { login: owner },
  } = data;

  // Timestamps as Numbers
  const createdMs = new Date(created_at).getTime();
  const updatedMs = new Date(updated_at).getTime();
  const age = createdMs ? Date.now() - createdMs : 0;

  return {
    // basic info
    name,
    fullName: full_name,
    description,
    url: html_url,
    owner,

    // languages from fetchLanguages()
    language: languages,

    // dates
    createdAt: createdMs,
    lastUpdate: updatedMs,
    age,

    // GitHub‐specific metadata
    topics,
    license: license?.name || null,

    // stats keyed by today’s date
    stars: { [today]: starsCount },
    forks: { [today]: forksCount },
    watches: { [today]: watchesCount },
    trendingDate: today,

    // compute trend score however you like
    stats: {
      trends: calculateTrendScore({
        stars: starsCount,
        forks: forksCount,
        watches: watchesCount,
        age,
      }),
      scrapedDate: today,
      category: [], // categorize later
      message: null, // a recommadned message generated by LLM
    },
  };
}

/**
 * Make request to GitHub API for languages.
 */
async function fetchLanguages(url) {
  const res = await fetch(url);
  if (!res.ok) {
    throw new Error(
      `fetchLanguages(${url}) failed: ${res.status} ${res.statusText}`,
    );
  }
  return res.json();
}

/**
 * Fetch full repo metadata + languages, then transform into DB-ready form.
 * @param {string} rawName  e.g. "facebook/react"
 * @param {string} today    e.g. "2025-05-04"
 */
async function processOneRepo(rawName, today) {
  const fullData = await getRepo(rawName);
  const langs = await fetchLanguages(fullData.languages_url);
  return transformRepo(fullData, langs, today);
}

export async function prepTrendingData() {
  const trendingList = await getTrending();
  const today = getTodayUTC();

  const results = await Promise.allSettled(
    trendingList.map((repoName) => processOneRepo(repoName, today)),
  );

  const repos = results
    .filter((result) => result.status === "fulfilled")
    .map((result) => result.value);

  results.forEach((r) => {
    if (r.status === "rejected") {
      console.error("Error processing repo:", r.reason);
    }
  });

  return repos;
}

/**
 * Upsert an array of already‑prepared repo objects in one bulkWrite.
 */
export async function saveTrendingData(repos) {
  if (!repos.length) return; // guard against empty ops

  const ops = repos.map((repo) => ({
    updateOne: {
      filter: { fullName: repo.fullName },
      update: { $set: repo },
      upsert: true,
    },
  }));

  await Repo.bulkWrite(ops);
}
